<!DOCTYPE html>
<html lang="pt-br">
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Forum&family=Pixelify+Sans:wght@400..700&display=swap" rel="stylesheet">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Meu Amor - Game</title>
  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
    // =============================
    // SCENE 1 - Start
    // =============================
    class StartScene extends Phaser.Scene {
      constructor() {
        super('StartScene');
      }

      create() {
        const titleText = this.add.text(400, 250, "Oi, meu amor,", {
          fontFamily: 'Pixelify Sans',
          fontWeight: '700',
          fontSize: '20px',
          color: "#ffffff",
          align: "center"
        }).setOrigin(0.5);

        const pressStartText = this.add.text(400, 350, "Pressione a BARRA DE ESPAÇO", {
          fontFamily: 'Pixelify Sans',
          fontSize: "20px",
          color: "#ffffff",
          align: "center"
        }).setOrigin(0.5);

        // Blink effect
        this.tweens.add({
          targets: pressStartText,
          alpha: 0,
          duration: 800,
          yoyo: true,
          repeat: -1
        });

        // Space to go to next scene
        this.input.keyboard.on('keydown-SPACE', () => {
          this.scene.start('RickMortyScene');
        });
      }
    }


    // =============================
    // RickMortyScene
    // =============================
    class RickMortyScene extends Phaser.Scene {
      constructor() {
        super('RickMortyScene');
        this.blockHit = false;
        this.mushroomCollected = false;
      }

      preload() {
        // Load player assets
        this.load.image('gui_normal', 'assets/gui_normal.png');
        // Adjust frameWidth and frameHeight as per your spritesheet
        this.load.image('gui_normal_walk', 'assets/gui_normal_walk.png');
        this.load.image('gui_normal_jump', 'assets/gui_normal_jump.png');
      }

      create() {
        this.physics.world.setBounds(0, 0, 800, 600);
        this.physics.world.gravity.y = 500;

        // Ground
        const ground = this.add.rectangle(400, 590, 800, 20, 0x654321);
        this.physics.add.existing(ground, true);

        // Player as a sprite now
        this.player = this.physics.add.sprite(100, 500, 'gui_normal');
        this.player.setCollideWorldBounds(true);
        this.physics.add.collider(this.player, ground);

        // Yellow Block
        this.block = this.add.rectangle(400, 400, 32, 32, 0xFFFF00);
        this.physics.add.existing(this.block, true);
        this.physics.add.collider(this.player, this.block, this.hitBlock, null, this);

        // Mushroom (initially hidden)
        this.mushroom = this.add.rectangle(400, 368, 20, 20, 0x00FF00);
        this.physics.add.existing(this.mushroom);
        this.mushroom.visible = false;
        this.mushroom.body.setAllowGravity(false);

        // Portal (initially hidden)
        this.portal = this.add.rectangle(750, 500, 50, 100, 0x00FFFF);
        this.physics.add.existing(this.portal, true);
        this.portal.visible = false;

        // Collider for the mushroom and ground
        this.physics.add.collider(this.mushroom, ground);
        this.physics.add.overlap(this.player, this.mushroom, this.collectMushroom, null, this);

        // Overlap for the portal
        this.physics.add.overlap(this.player, this.portal, this.enterPortal, null, this);

        // Input keys
        this.cursors = this.input.keyboard.createCursorKeys();

        // Instructions
        this.infoText = this.add.text(400, 100, 
          "Bata de cabeça no bloco amarelo para liberar o cogumelo!\nUse as setas para mover, Espaço para pular.", 
          { font: "16px Arial", fill: "#ffffff", align: "center" }
        ).setOrigin(0.5);
      }

      update() {
        const speed = 160;
        const onGround = this.player.body.blocked.down; // Ensure onGround is defined
        const vx = this.player.body.velocity.x;

        // Horizontal movement
        if (this.cursors.left.isDown) {
          this.player.body.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
          this.player.body.setVelocityX(speed);
        } else {
          this.player.body.setVelocityX(0);
        }

        // Jump if on the ground
        if ((this.cursors.up.isDown || this.cursors.space.isDown) && onGround) {
          this.player.body.setVelocityY(-400);
        }

        // Update player animations based on state
        if (!onGround) {
          // Jumping or falling
          this.player.setTexture('gui_normal_jump');
        } else {
          // On the ground
          if (this.player.body.velocity.x !== 0) {
            // Walking
            this.player.setTexture('gui_normal_walk');
          } else {
            // Standing still
            this.player.setTexture('gui_normal');
          }
        }
      }

      hitBlock(player, block) {
        if (!this.blockHit && player.body.touching.up) {
          this.blockHit = true;
          this.mushroom.visible = true;
          this.mushroom.body.setAllowGravity(true);
        }
      }

      collectMushroom(player, mushroom) {
        if (!this.mushroomCollected) {
          this.mushroomCollected = true;
          mushroom.destroy();
          this.portal.visible = true;
        }
      }

      enterPortal(player, portal) {
        this.scene.start('RickMortyMessage');
      }
    }


    // =============================
    // RickMortyMessage
    // =============================
    class RickMortyMessage extends Phaser.Scene {
      constructor() {
        super('RickMortyMessage');
        this.gCount = 0;
      }

      create() {
        this.cameras.main.setBackgroundColor('#000000');
        this.add.text(400, 300, "Tela preta: Pressione G duas vezes para continuar",
          { font: "20px Arial", fill: "#ffffff", align: "center"}).setOrigin(0.5);

        this.gKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
      }

      update() {
        if (Phaser.Input.Keyboard.JustDown(this.gKey)) {
          this.gCount++;
          if (this.gCount >= 2) {
            this.scene.start('TimeBreakScene');
          }
        }
      }
    }

    // =============================
    // TimeBreakScene
    // =============================
    class TimeBreakScene extends Phaser.Scene {
      constructor() {
        super('TimeBreakScene');
        this.enemyDead = false;
        this.hasGun = false;
        this.fragmentCams = [];
      }

      preload() {
        // Create bullet texture
        const bulletCanvas = this.textures.createCanvas('bullet', 2, 2);
        bulletCanvas.context.fillStyle = '#ffffff';
        bulletCanvas.context.fillRect(0,0,2,2);
        bulletCanvas.refresh();

        // Load player assets again
        this.load.image('gui_normal', 'assets/gui_normal.png');
        this.load.image('gui_normal_walk', 'assets/gui_normal_walk.png');
        this.load.image('gui_normal_jump', 'assets/gui_normal_jump.png');
      }

      create() {
        this.physics.world.setBounds(0, 0, 800, 600);
        this.physics.world.gravity.y = 500;

        // Ground
        this.ground = this.add.rectangle(400, 590, 800, 20, 0x654321);
        this.physics.add.existing(this.ground, true);

        // Player as sprite
        this.player = this.physics.add.sprite(100, 500, 'gui_normal');
        this.player.setCollideWorldBounds(true);
        this.physics.add.collider(this.player, this.ground);

        // Enemy
        this.enemy = this.add.rectangle(600, 500, 30, 50, 0xff00ff);
        this.physics.add.existing(this.enemy);
        this.enemy.body.setCollideWorldBounds(true);
        this.physics.add.collider(this.enemy, this.ground);

        // Gun
        this.gunSpawnX = 700; 
        this.gunSpawnY = 550;
        this.addGun(this.ground);

        // Bullets
        this.bullets = this.physics.add.group({ allowGravity: false });

        // Overlaps
        this.physics.add.overlap(this.bullets, this.enemy, this.shootEnemy, null, this);
        this.physics.add.overlap(this.player, this.enemy, this.enemyHitPlayer, null, this);

        // Input
        this.cursors = this.input.keyboard.createCursorKeys();
        this.shootKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

        // Respawn point
        this.spawnPoint = { x: 100, y: 500 };

        // Portals setup
        this.portalLeft = this.add.rectangle(100, 500, 50, 100, 0x00FFFF);
        this.physics.add.existing(this.portalLeft, true);
        this.portalLeft.visible = false;
        this.portalLeft.body.enable = false;

        this.portalRight = this.add.rectangle(700, 500, 50, 100, 0x00FFFF);
        this.physics.add.existing(this.portalRight, true);
        this.portalRight.visible = false;
        this.portalRight.body.enable = false;

        this.physics.add.overlap(this.player, this.portalRight, this.enterRightPortal, null, this);
      }

      update() {
        const speed = 160;
        const onGround = this.player.body.blocked.down; // Ensure onGround is defined here too

        // Movement
        if (this.cursors.left.isDown) {
          this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
          this.player.setVelocityX(speed);
        } else {
          this.player.setVelocityX(0);
        }

        // Jump
        if ((this.cursors.up.isDown || this.cursors.space.isDown) && onGround) {
          this.player.setVelocityY(-400);
        }

        // Animate based on state
        if (!onGround) {
          // Jump/fall
          this.player.setTexture('gui_normal_jump');
        } else {
          if (this.player.body.velocity.x !== 0) {
            // Walking
            this.player.setTexture('gui_normal_walk');
          } else {
            // Idle
            this.player.setTexture('gui_normal');
          }
        }

        // Enemy follow if alive
        if (!this.enemyDead) {
          if (this.player.x < this.enemy.x) {
            this.enemy.body.setVelocityX(-100);
          } else {
            this.enemy.body.setVelocityX(100);
          }
        }
      }

      addGun(ground) {
        this.gun = this.add.rectangle(this.gunSpawnX, this.gunSpawnY, 20, 10, 0xffff00);
        this.physics.add.existing(this.gun);
        this.physics.add.collider(this.gun, ground);
        this.physics.add.overlap(this.player, this.gun, this.collectGun, null, this);
      }

      collectGun(player, gun) {
        this.hasGun = true;
        gun.destroy();
        this.add.text(400, 100, "You got the gun! Press SPACE to shoot.", 
          { font: "16px Arial", fill: "#ffffff" }).setOrigin(0.5);
      }

      shootBullet() {
        const bullet = this.bullets.create(this.player.x + 20, this.player.y, 'bullet');
        bullet.setDisplaySize(10, 5);
        bullet.body.setVelocityX(400);
      }

      shootEnemy(bullet, enemy) {
        bullet.destroy();
        this.killEnemy();
      }

      enemyHitPlayer(player, enemy) {
        if (!this.enemyDead) {
          this.hasGun = false;
          this.respawnPlayer();
          this.addGun(this.ground);
        }
      }

      respawnPlayer() {
        this.player.setPosition(this.spawnPoint.x, this.spawnPoint.y);
        this.player.body.setVelocity(0);
      }

      killEnemy() {
        if (this.enemyDead) return;
        this.enemyDead = true;
        this.enemy.destroy();

        // Fragmentation cameras
        const rows = 4;
        const cols = 5;
        const camWidth = 800 / cols;
        const camHeight = 600 / rows;
        const zoomFactor = 0.2;

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const cam = this.cameras.add(col * camWidth, row * camHeight, camWidth, camHeight);
            cam.setScroll(400, 300);
            cam.setZoom(zoomFactor);
            this.fragmentCams.push(cam);
          }
        }
        this.cameras.main.setVisible(false);

        // Player dialog after 1s
        this.time.delayedCall(1000, () => {
          this.add.text(400, 100, "O que foi que eu fiz, mano...", {
            font: "18px Arial", fill: "#fff", align: "center"
          }).setOrigin(0.5);
        });

        // Rick & Morty appear at ground level and move in
        this.time.delayedCall(3000, () => {
          this.rick = this.add.rectangle(900, 500, 30, 50, 0x0000ff);
          this.morty = this.add.rectangle(950, 500, 30, 50, 0xffff00);

          this.physics.add.existing(this.rick);
          this.physics.add.existing(this.morty);
          this.rick.body.setCollideWorldBounds(true);
          this.morty.body.setCollideWorldBounds(true);
          this.physics.add.collider(this.rick, this.ground);
          this.physics.add.collider(this.morty, this.ground);

          // Move them to player's vicinity
          this.tweens.add({
            targets: this.rick,
            x: this.player.x + 30,
            duration: 2000,
            ease: 'Linear'
          });
          this.tweens.add({
            targets: this.morty,
            x: this.player.x + 70,
            duration: 2000,
            ease: 'Linear'
          });

          // Show their dialogue after they arrive (about 5s total)
          this.time.delayedCall(5000, () => {
            this.rickText = this.add.text(400, 240, "Rick: Mds, e agora, bravos, olha o que você fez!!! Quem vai nos ajudar?", {
              font: "16px Arial", fill: "#0f0", align: "center"
            }).setOrigin(0.5);

            this.mortyText = this.add.text(400, 260, "Morty: ...", {
              font: "16px Arial", fill: "#0f0", align: "center"
            }).setOrigin(0.5);
          });
        });

        // Another character comes from left at ground level after 8s
        this.time.delayedCall(8000, () => {
          this.newChar = this.add.rectangle(-50, 500, 30, 50, 0xff69b4);
          this.physics.add.existing(this.newChar);
          this.newChar.body.setCollideWorldBounds(true);
          this.physics.add.collider(this.newChar, this.ground);

          // Move the new character to the player
          this.tweens.add({
            targets: this.newChar,
            x: this.player.x,
            duration: 2000,
            ease: 'Linear',
            onComplete: () => {
              // Show kiss text
              this.newCharText = this.add.text(400, 340, "??? aparece e beija o jogador", {
                font: "16px Arial", fill: "#ff69b4", align: "center"
              }).setOrigin(0.5);

              // Remove fragment
              this.fragmentCams.forEach(cam => this.cameras.remove(cam));
              this.fragmentCams = [];
              this.cameras.main.setVisible(true);

              // Rick & Morty react after 2s
              this.time.delayedCall(2000, () => {
                if (this.rickText) this.rickText.setText("Rick: Nossa, nem acredito que o amor faz isso.");
                if (this.mortyText) this.mortyText.setText("Morty: É incrível...");
              });
            }
          });
        });

        // Show left portal for Rick & Morty after 12s
        this.time.delayedCall(12000, () => {
          this.portalLeft.visible = true;

          // Move Rick & Morty into the left portal after 2s (14s total)
          this.time.delayedCall(14000, () => {
            if (this.rickText) this.rickText.setText("Rick: Que chato isso...");
            if (this.mortyText) this.mortyText.setText("Morty: Vamos embora...");

            // Make left portal visible and enable its body
            this.portalLeft.visible = true;
            this.portalLeft.body.enable = true;

            // Tween them into portalLeft.x, then destroy them
            this.tweens.add({
              targets: [this.rick, this.morty],
              x: this.portalLeft.x,
              duration: 2000,
              ease: 'Linear',
              onComplete: () => {
                if (this.rickText) this.rickText.destroy();
                if (this.mortyText) this.mortyText.destroy();
                if (this.rick) this.rick.destroy();
                if (this.morty) this.morty.destroy();
                this.portalLeft.setFillStyle(0x00ffff); 
                this.portalLeft.setSize(50,100);
                this.portalLeft.setVisible(true);

                this.time.delayedCall(1000, () => {
                  // Close the left portal
                  this.portalLeft.visible = false;

                  if (this.newCharText) this.newCharText.setText("??? : Vamos pra um mundo mágico agora!");

                  // Show right portal after 2 more seconds (19s total)
                  this.time.delayedCall(2000, () => {
                    // Make right portal visible and enable its body
                    this.portalRight.visible = true;
                    this.portalRight.body.enable = true;
                  });
                });
              }
            });
          });
        });
      }

      enterRightPortal(player, portal) {
        // When player (and presumably newChar is near) touches the right portal, go to next scene
        this.scene.start('RickMortyMessage');
      }
    }

    // =============================
    // GAME CONFIG
    // =============================
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 600,
      backgroundColor: "#000000",
      scene: [
        StartScene, RickMortyScene, RickMortyMessage, TimeBreakScene
      ],
      physics: {
        default: 'arcade',
        arcade: { debug: false }
      }
    };

    new Phaser.Game(config);
  </script>
</head>
<body>
</body>
</html>
