<!DOCTYPE html>
<html lang="pt-br">
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Forum&family=Pixelify+Sans:wght@400..700&display=swap" rel="stylesheet">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Meu Amor - Game</title>
  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>
    // =============================
    // SCENE 1 - Start
    // =============================
    class StartScene extends Phaser.Scene {
      constructor() {
        super('StartScene');
      }

      create() {
        const titleText = this.add.text(400, 250, "Oi, meu amor,", {
          fontFamily: 'Pixelify Sans',
          fontWeight: '700',
          fontSize: '20px',
          color: "#ffffff",
          align: "center"
        }).setOrigin(0.5);

        const pressStartText = this.add.text(400, 350, "Pressione a BARRA DE ESPAÇO", {
          fontFamily: 'Pixelify Sans',
          fontSize: "20px",
          color: "#ffffff",
          align: "center"
        }).setOrigin(0.5);

        // Blink effect
        this.tweens.add({
          targets: pressStartText,
          alpha: 0,
          duration: 800,
          yoyo: true,
          repeat: -1
        });

        // Space to go to next scene
        this.input.keyboard.on('keydown-SPACE', () => {
          this.scene.start('RickMortyScene');
        });
      }
    }

    // =============================
    // RickMortyScene
    // =============================
    class RickMortyScene extends Phaser.Scene {
      constructor() {
        super('RickMortyScene');
        this.blockHit = false;
        this.mushroomCollected = false;
        this.facing = 'right'; // keep track of current facing direction: 'left' or 'right'
        this.walkFrameCounter = 0; // a counter to help us alternate walking sprites
      }

      preload() {
        // Load all directional sprites
        this.load.image('gui_normal_left', 'assets/gui_normal_left.png');
        this.load.image('gui_normal_right', 'assets/gui_normal_right.png');
        this.load.image('gui_normal_walk_left', 'assets/gui_normal_walk_left.png');
        this.load.image('gui_normal_walk_right', 'assets/gui_normal_walk_right.png');
        this.load.image('gui_normal_jump_left', 'assets/gui_normal_jump_left.png');
        this.load.image('gui_normal_jump_right', 'assets/gui_normal_jump_right.png');
      
        const graphics = this.make.graphics({ x: 0, y: 0, add: false });
          graphics.fillStyle(0xffffff, 1);
          graphics.fillCircle(2, 2, 2);
          graphics.generateTexture('particle', 4, 4);
      }

      create() {
        this.physics.world.setBounds(0, 0, 800, 600);
        this.physics.world.gravity.y = 500;

        // Ground
        const ground = this.add.rectangle(400, 590, 800, 20, 0x654321);
        this.physics.add.existing(ground, true);

        // Player
        this.player = this.physics.add.sprite(100, 500, 'gui_normal_right');
        this.player.setScale(0.1);
        this.player.setCollideWorldBounds(true);
        this.physics.add.collider(this.player, ground);

        // Yellow Block
        this.block = this.add.rectangle(400, 400, 32, 32, 0xFFFF00);
        this.physics.add.existing(this.block, true);
        this.physics.add.collider(this.player, this.block, this.hitBlock, null, this);

        // Mushroom
        this.mushroom = this.add.rectangle(400, 368, 20, 20, 0x00FF00);
        this.physics.add.existing(this.mushroom);
        this.mushroom.visible = false;
        this.mushroom.body.setAllowGravity(false);

        // Portal
        this.portal = this.add.rectangle(750, 500, 50, 100, 0x00FFFF);
        this.physics.add.existing(this.portal, true);
        this.portal.visible = false;

        // Colliders and Overlaps
        this.physics.add.collider(this.mushroom, ground);
        this.physics.add.overlap(this.player, this.mushroom, this.collectMushroom, null, this);
        this.physics.add.overlap(this.player, this.portal, this.enterPortal, null, this);

        // Inputs
        this.cursors = this.input.keyboard.createCursorKeys();

        // Info Text
        this.infoText = this.add.text(400, 100, 
          "Bata de cabeça no bloco amarelo para liberar o cogumelo!\nUse as setas para mover, Espaço para pular.", 
          { font: "16px Arial", fill: "#ffffff", align: "center" }
        ).setOrigin(0.5);
      }

      /**
       * Emits a burst of particles at the specified (x, y) position.
       * @param {number} x - The x-coordinate where the burst occurs.
       * @param {number} y - The y-coordinate where the burst occurs.
       */
      emitParticleBurst(x, y) {
        const particleCount = 20; // Number of particles per burst
        for (let i = 0; i < particleCount; i++) {
          const angle = Phaser.Math.Between(0, 360);
          const speed = Phaser.Math.Between(50, 150);
          const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;
          const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;

          const particle = this.add.sprite(x, y, 'particle');
          this.physics.add.existing(particle);
          particle.body.setVelocity(velocityX, velocityY);
          particle.body.setAllowGravity(false);

          // Animate particle scaling and fading
          this.tweens.add({
            targets: particle,
            alpha: 0,
            scale: { from: 1, to: 0 },
            duration: 500,
            onComplete: () => {
              particle.destroy();
            }
          });
        }
      }

      update() {
        const speed = 160;
        const onGround = this.player.body.blocked.down;

        // Reset walking frame counter if standing still
        if (this.player.body.velocity.x === 0) {
          this.walkFrameCounter = 0;
        }

        // Horizontal movement input
        if (this.cursors.left.isDown) {
          this.player.body.setVelocityX(-speed);
          this.facing = 'left'; // face left if moving left
        } else if (this.cursors.right.isDown) {
          this.player.body.setVelocityX(speed);
          this.facing = 'right'; // face right if moving right
        } else {
          this.player.body.setVelocityX(0);
        }

        // Jumping
        if ((this.cursors.up.isDown ) && onGround) {
          this.player.body.setVelocityY(-400);
        }

        // Determine sprite based on state
        if (!onGround) {
          // Player is jumping or falling
          // If facing left, use jump_left; if right, use jump_right
          if (this.facing === 'left') {
            this.player.setTexture('gui_normal_jump_left');
          } else {
            this.player.setTexture('gui_normal_jump_right');
          }
        } else {
          // Player is on the ground
          if (this.player.body.velocity.x !== 0) {
            // Player is walking
            // Alternate between idle and walk texture to simulate walking
            this.walkFrameCounter++;
            if (this.facing === 'left') {
              // Alternate between normal_left and walk_left
              if (this.walkFrameCounter % 20 < 10) {
                this.player.setTexture('gui_normal_left');
              } else {
                this.player.setTexture('gui_normal_walk_left');
              }
            } else {
              // Facing right, alternate between normal_right and walk_right
              if (this.walkFrameCounter % 20 < 10) {
                this.player.setTexture('gui_normal_right');
              } else {
                this.player.setTexture('gui_normal_walk_right');
              }
            }
          } else {
            // Player is idle
            // Just show idle texture according to facing direction
            if (this.facing === 'left') {
              this.player.setTexture('gui_normal_left');
            } else {
              this.player.setTexture('gui_normal_right');
            }
          }
        }
      }

      hitBlock(player, block) {
      // Trigger the block hit effects only if the player is hitting from below
      if (player.body.touching.up) {
        // Handle mushroom release once
        if (!this.blockHit) {
          this.blockHit = true;
          this.mushroom.visible = true;
          this.mushroom.body.setAllowGravity(true);
        }

        // Change block color to red
        block.setFillStyle(0xFF0000); // Red color
        // Revert to original color after 0.5 seconds
        this.time.delayedCall(500, () => {
          block.setFillStyle(0xFFFF00); // Original yellow color
        });

        // Emit particle burst at block's position
        this.emitParticleBurst(block.x, block.y);
      }
    }


      collectMushroom(player, mushroom) {
        if (!this.mushroomCollected) {
          this.mushroomCollected = true;
          mushroom.destroy();
          this.portal.visible = true;
        }
      }

      enterPortal(player, portal) {
        this.scene.start('RickMortyMessage');
      }
    }

    // =============================
    // RickMortyMessage
    // =============================
    class RickMortyMessage extends Phaser.Scene {
      constructor() {
        super('RickMortyMessage');
        this.gCount = 0;
      }

      create() {
        this.cameras.main.setBackgroundColor('#000000');
        this.add.text(400, 300, "Tela preta: Pressione G duas vezes para continuar",
          { font: "20px Arial", fill: "#ffffff", align: "center"}).setOrigin(0.5);

        this.gKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
      }

      update() {
        if (Phaser.Input.Keyboard.JustDown(this.gKey)) {
          this.gCount++;
          if (this.gCount >= 2) {
            this.scene.start('TimeBreakScene');
          }
        }
      }
    }

    // =============================
    // TimeBreakScene
    // =============================
    class TimeBreakScene extends Phaser.Scene {
      constructor() {
        super('TimeBreakScene');
        
        // Enemy state
        this.enemyDead = false;
        
        // Player state
        this.hasGun = false;
        this.direction = 'right'; // 'left' or 'right'
        this.isJumping = false;
        this.walkFrame = 0; // To alternate walking sprites
        this.walkTimer = 0; // Timer to control sprite switching
        
        // Fragmented Cameras
        this.fragmentCams = [];
        
        // Character Variables
        this.rick = null;
        this.morty = null;
        this.giullya = null;
        
        // Dialogue Text Variables
        this.rickText = null;
        this.mortyText = null;
        this.giullyaText = null;
        
        // Gun Variable
        this.gun = null;
        
        // Portals
        this.portalLeft = null;
        this.portalRight = null;
        
        // Bullets Group
        this.bullets = null;
        
        // Other Game Objects
        this.ground = null;
        this.player = null;
        this.enemy = null;
        
        // Input Keys
        this.cursors = null;
        this.shootKey = null;
        
        // Spawn Point
        this.spawnPoint = { x: 100, y: 500 };
    }

      preload() {
      // Create bullet texture
      const bulletCanvas = this.textures.createCanvas('bullet', 2, 2);
      bulletCanvas.context.fillStyle = '#ffffff';
      bulletCanvas.context.fillRect(0, 0, 2, 2);
      bulletCanvas.refresh();

      // Load player assets
      // Idle/Normal Sprites
      this.load.image('gui_normal_left', 'assets/gui_normal_left.png');
      this.load.image('gui_normal_right', 'assets/gui_normal_right.png');
      this.load.image('gui_normal_left_gun', 'assets/gui_normal_left_gun.png');
      this.load.image('gui_normal_right_gun', 'assets/gui_normal_right_gun.png');

      // Walking Sprites
      this.load.image('gui_normal_walk_left', 'assets/gui_normal_walk_left.png');
      this.load.image('gui_normal_walk_right', 'assets/gui_normal_walk_right.png');
      this.load.image('gui_normal_walk_left_gun', 'assets/gui_normal_walk_left_gun.png');
      this.load.image('gui_normal_walk_right_gun', 'assets/gui_normal_walk_right_gun.png');

      // Jumping Sprites
      this.load.image('gui_normal_jump_left', 'assets/gui_normal_jump_left.png');
      this.load.image('gui_normal_jump_right', 'assets/gui_normal_jump_right.png');
      this.load.image('gui_normal_jump_left_gun', 'assets/gui_normal_jump_left_gun.png');
      this.load.image('gui_normal_jump_right_gun', 'assets/gui_normal_jump_right_gun.png');

      // Load Rick & Morty
      this.load.image('rick_still_gun_left', 'assets/characters/rick_still_gun_left.png');
      this.load.image('rick_middle_finger_left', 'assets/characters/rick_middle_finger_left.png');
      this.load.image('rick_still_left', 'assets/characters/rick_still_left.png');
      this.load.image('rick_walking_left', 'assets/characters/rick_walking_left.png');
      this.load.image('rick_walking_right', 'assets/characters/rick_walking_right.png'); // Added
      this.load.image('rick_still_right', 'assets/characters/rick_still_right.png');     // Added

      this.load.image('morty_middle_finger_left', 'assets/characters/morty_middle_finger_left.png');
      this.load.image('morty_still_left', 'assets/characters/morty_still_left.png');
      this.load.image('morty_walking_left', 'assets/characters/morty_walking_left.png');
      this.load.image('morty_walking_right', 'assets/characters/morty_walking_right.png'); // Added
      this.load.image('morty_still_right', 'assets/characters/morty_still_right.png');     // Added

      // Load Giullya
      this.load.image('giullya_kissing_right', 'assets/characters/giullya_kissing_right.png');
      this.load.image('giullya_still_right', 'assets/characters/giullya_still_right.png');
      this.load.image('giullya_walking_right', 'assets/characters/giullya_walking_right.png');
      this.load.image('giullya_walking_left', 'assets/characters/giullya_walking_left.png');   // Added
      this.load.image('giullya_still_left', 'assets/characters/giullya_still_left.png');       // Added
  }

      create() {
        this.physics.world.setBounds(0, 0, 800, 600);
        this.physics.world.gravity.y = 500;

        // Ground
        this.ground = this.add.rectangle(400, 590, 800, 20, 0x654321);
        this.physics.add.existing(this.ground, true);

        // Player as sprite
        this.player = this.physics.add.sprite(100, 500, 'gui_normal_right');
        this.player.setScale(0.05);
        this.player.setCollideWorldBounds(true);
        this.physics.add.collider(this.player, this.ground);

        // Initialize player state
        this.direction = 'right';
        this.isJumping = false;

        // Enemy
        this.enemy = this.add.rectangle(600, 500, 30, 50, 0xff00ff);
        this.physics.add.existing(this.enemy);
        this.enemy.body.setCollideWorldBounds(true);
        this.physics.add.collider(this.enemy, this.ground);

        // Gun
        this.gunSpawnX = 700;
        this.gunSpawnY = 550;
        this.addGun(this.ground);

        // Bullets
        this.bullets = this.physics.add.group({ allowGravity: false });

        // Overlaps
        this.physics.add.overlap(this.bullets, this.enemy, this.shootEnemy, null, this);
        this.physics.add.overlap(this.player, this.enemy, this.enemyHitPlayer, null, this);

        // Input
        this.cursors = this.input.keyboard.createCursorKeys();
        this.shootKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

        // Rick's state
        this.rickDirection = 'left';
        this.rickWalkFrame = 0;
        this.rickWalkTimer = 0;

        // Morty's state
        this.mortyDirection = 'left';
        this.mortyWalkFrame = 0;
        this.mortyWalkTimer = 0;

        // Giullya's state
        this.giullyaDirection = 'right';
        this.giullyaWalkFrame = 0;
        this.giullyaWalkTimer = 0;

        // Respawn point
        this.spawnPoint = { x: 100, y: 500 };

        // Portals setup
        this.portalLeft = this.add.rectangle(100, 500, 50, 100, 0x00FFFF);
        this.physics.add.existing(this.portalLeft, true);
        this.portalLeft.visible = false;
        this.portalLeft.body.enable = false;

        this.portalRight = this.add.rectangle(700, 500, 50, 100, 0x00FFFF);
        this.physics.add.existing(this.portalRight, true);
        this.portalRight.visible = false;
        this.portalRight.body.enable = false;

        this.physics.add.overlap(this.player, this.portalRight, this.enterRightPortal, null, this);
    }
      
      update(time, delta) {
        const speed = 160;
        const onGround = this.player.body.blocked.down;

        // Reset velocity
        this.player.setVelocityX(0);

        // Movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
            this.direction = 'left';
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
            this.direction = 'right';
        }

        // Jump
        if (this.cursors.up.isDown && onGround) {
            this.player.setVelocityY(-400);
            this.isJumping = true;
        }

        // Check if player is on ground to reset jumping state
        if (onGround && this.isJumping) {
            this.isJumping = false;
            // Reset walk timer when landing
            this.walkTimer = 0;
            this.walkFrame = 0;
        }

        // Handle shooting
        if (Phaser.Input.Keyboard.JustDown(this.shootKey) && this.hasGun) {
            this.shootBullet();
        }

        // Update player sprite based on state
        this.updatePlayerSprite(delta);
        
        // Enemy follows the player if alive
        if (!this.enemyDead && this.enemy) {
            if (this.player.x < this.enemy.x) {
                this.enemy.body.setVelocityX(-100);
            } else {
                this.enemy.body.setVelocityX(100);
            }
        }

        // Update Rick's sprite if he exists
        if (this.rick) {
            ({ walkFrame: this.rickWalkFrame, walkTimer: this.rickWalkTimer } = this.updateCharacterSprite(
                this.rick,
                this.rickDirection,
                this.rickWalkFrame,
                this.rickWalkTimer,
                delta,
                {
                    walkLeft: 'rick_walking_left',
                    walkRight: 'rick_walking_right',
                    idleLeft: 'rick_still_left',
                    idleRight: 'rick_still_right'
                }
            ));
        }

        // Update Morty's sprite if he exists
        if (this.morty) {
            ({ walkFrame: this.mortyWalkFrame, walkTimer: this.mortyWalkTimer } = this.updateCharacterSprite(
                this.morty,
                this.mortyDirection,
                this.mortyWalkFrame,
                this.mortyWalkTimer,
                delta,
                {
                    walkLeft: 'morty_walking_left',
                    walkRight: 'morty_walking_right',
                    idleLeft: 'morty_still_left',
                    idleRight: 'morty_still_right'
                }
            ));
        }

        // Update Giullya's sprite if she exists
        if (this.giullya) {
            ({ walkFrame: this.giullyaWalkFrame, walkTimer: this.giullyaWalkTimer } = this.updateCharacterSprite(
                this.giullya,
                this.giullyaDirection,
                this.giullyaWalkFrame,
                this.giullyaWalkTimer,
                delta,
                {
                    walkLeft: 'giullya_walking_left',
                    walkRight: 'giullya_walking_right',
                    idleLeft: 'giullya_still_left',
                    idleRight: 'giullya_still_right'
                }
            ));
        }
    }

      updatePlayerSprite(delta) {
        // Update walk timer
        this.walkTimer += delta;

        // Determine current sprite based on state
        let spriteKey = '';

        if (this.isJumping) {
            // Set jumping sprite based on direction and gun state
            if (this.direction === 'left') {
                spriteKey = this.hasGun ? 'gui_normal_jump_left_gun' : 'gui_normal_jump_left';
            } else {
                spriteKey = this.hasGun ? 'gui_normal_jump_right_gun' : 'gui_normal_jump_right';
            }
            this.player.setTexture(spriteKey);
            return; // Do not proceed to walking or idle if jumping
        }

        if (this.player.body.velocity.x !== 0) {
            // Player is moving: handle walking animation
            if (this.walkTimer >= 100) { // Change sprite every 100ms for smoother animation
                this.walkFrame = (this.walkFrame + 1) % 2; // Toggle between 0 and 1
                this.walkTimer = 0;
            }

            if (this.walkFrame === 0) {
                // Walking Frame 1
                if (this.direction === 'left') {
                    spriteKey = this.hasGun ? 'gui_normal_walk_left_gun' : 'gui_normal_walk_left';
                } else {
                    spriteKey = this.hasGun ? 'gui_normal_walk_right_gun' : 'gui_normal_walk_right';
                }
            } else {
                // Walking Frame 2 (Idle Sprite to simulate walking)
                if (this.direction === 'left') {
                    spriteKey = this.hasGun ? 'gui_normal_left_gun' : 'gui_normal_left';
                } else {
                    spriteKey = this.hasGun ? 'gui_normal_right_gun' : 'gui_normal_right';
                }
            }

            this.player.setTexture(spriteKey);
        } else {
            // Player is idle: set to idle sprite based on direction and gun state
            if (this.direction === 'left') {
                spriteKey = this.hasGun ? 'gui_normal_left_gun' : 'gui_normal_left';
            } else {
                spriteKey = this.hasGun ? 'gui_normal_right_gun' : 'gui_normal_right';
            }
            this.player.setTexture(spriteKey);
            // Reset walk animation state
            this.walkFrame = 0;
            this.walkTimer = 0;
        }
    }
          
      updateCharacterSprite(character, direction, walkFrame, walkTimer, delta, spriteKeys) {
        if (!character || !character.body) {
            return { walkFrame, walkTimer };
        }

        // Update walk timer
        walkTimer += delta;

        if (walkTimer >= 100) {
            walkFrame = (walkFrame + 1) % 2; // Toggle between 0 and 1
            walkTimer = 0;
        }

        let spriteKey = '';

        if (character.body.velocity.x !== 0) {
            // Walking animation
            if (walkFrame === 0) {
                spriteKey = direction === 'left' ? spriteKeys.walkLeft : spriteKeys.walkRight;
            } else {
                spriteKey = direction === 'left' ? spriteKeys.idleLeft : spriteKeys.idleRight;
            }
        } else {
            // Idle sprite
            spriteKey = direction === 'left' ? spriteKeys.idleLeft : spriteKeys.idleRight;
        }

        character.setTexture(spriteKey);

        return { walkFrame, walkTimer };
      }


      addGun(ground) {
        this.gun = this.add.rectangle(this.gunSpawnX, this.gunSpawnY, 20, 10, 0xffff00);
        this.physics.add.existing(this.gun);
        this.physics.add.collider(this.gun, ground);
        this.physics.add.overlap(this.player, this.gun, this.collectGun, null, this);
      }

      collectGun(player, gun) {
        this.hasGun = true;
        gun.destroy();
        this.add.text(400, 100, "You got the gun! Press SPACE to shoot.", 
          { font: "16px Arial", fill: "#ffffff" }).setOrigin(0.5).setScrollFactor(0);
      }

      shootBullet() {
        const bullet = this.bullets.create(this.player.x + (this.direction === 'right' ? 20 : -20), this.player.y, 'bullet');
        bullet.setDisplaySize(10, 5);
        bullet.body.setVelocityX(this.direction === 'right' ? 400 : -400);
      }

      shootEnemy(bullet, enemy) {
        bullet.destroy();
        this.killEnemy();
      }

      enemyHitPlayer(player, enemy) {
        if (!this.enemyDead) {
          this.hasGun = false;
          this.respawnPlayer();
          this.addGun(this.ground);
        }
      }

      respawnPlayer() {
        this.player.setPosition(this.spawnPoint.x, this.spawnPoint.y);
        this.player.body.setVelocity(0);
        this.isJumping = false;
        this.direction = 'right'; // Reset direction or keep current
      }

      killEnemy() {
        if (this.enemyDead) return;
        this.enemyDead = true;
        this.enemy.destroy();

        // Fragmentation cameras
        const rows = 4;
        const cols = 5;
        const camWidth = 800 / cols;
        const camHeight = 600 / rows;
        const zoomFactor = 0.2;

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const cam = this.cameras.add(col * camWidth, row * camHeight, camWidth, camHeight);
            cam.setScroll(400, 300);
            cam.setZoom(zoomFactor);
            this.fragmentCams.push(cam);
          }
        }
        this.cameras.main.setVisible(false);

        // Player dialog after 1s
        this.time.delayedCall(1000, () => {
          this.add.text(400, 100, "O que foi que eu fiz, mano...", {
            font: "18px Arial", fill: "#fff", align: "center"
          }).setOrigin(0.5).setScrollFactor(0);
        });

        // Rick & Morty appear at ground level and move in
        this.time.delayedCall(3000, () => {
          this.rick = this.physics.add.sprite(100, 500, 'rick_still_left');
          this.morty = this.physics.add.sprite(100, 500, 'morty_still_left');
          this.rick.setScale(0.5);
          this.morty.setScale(0.5);

          this.physics.add.existing(this.rick);
          this.physics.add.existing(this.morty);
          this.rick.body.setCollideWorldBounds(true);
          this.morty.body.setCollideWorldBounds(true);
          this.physics.add.collider(this.rick, this.ground);
          this.physics.add.collider(this.morty, this.ground);

          // Move them to player's vicinity
          this.tweens.add({
            targets: this.rick,
            x: this.player.x + 30,
            duration: 2000,
            ease: 'Linear'
          });
          this.tweens.add({
            targets: this.morty,
            x: this.player.x + 70,
            duration: 2000,
            ease: 'Linear'
          });

          // Show their dialogue after they arrive (about 5s total)
          this.time.delayedCall(5000, () => {
            this.rickText = this.add.text(400, 240, "Rick: Mds, e agora, bravos, olha o que você fez!!! Quem vai nos ajudar?", {
              font: "16px Arial", fill: "#0f0", align: "center"
            }).setOrigin(0.5).setScrollFactor(0);

            this.mortyText = this.add.text(400, 260, "Morty: ...", {
              font: "16px Arial", fill: "#0f0", align: "center"
            }).setOrigin(0.5).setScrollFactor(0);
          });
        });

        // Another character comes from left at ground level after 8s
        this.time.delayedCall(8000, () => {
          this.giullya = this.physics.add.sprite(100, 500, 'giullya_still_right');
          this.giullya.setScale(0.5);
          this.physics.add.existing(this.giullya);
          this.giullya.body.setCollideWorldBounds(true);
          this.physics.add.collider(this.giullya, this.ground);

          // Move the giullya to the player
          this.tweens.add({
            targets: this.giullya,
            x: this.player.x - 30,
            duration: 2000,
            ease: 'Linear',
            onComplete: () => {
              // Show kiss text
              this.giullyaText = this.add.text(400, 340, "??? aparece e beija o jogador", {
                font: "16px Arial", fill: "#ff69b4", align: "center"
              }).setOrigin(0.5).setScrollFactor(0);

              // Remove fragment
              this.fragmentCams.forEach(cam => this.cameras.remove(cam));
              this.fragmentCams = [];
              this.cameras.main.setVisible(true);

              // Rick & Morty react after 2s
              this.time.delayedCall(2000, () => {
                if (this.rickText) this.rickText.setText("Rick: Nossa, nem acredito que o amor faz isso.");
                if (this.mortyText) this.mortyText.setText("Morty: É incrível...");
              });
            }
          });
        });

        // Show left portal for Rick & Morty after 12s
        this.time.delayedCall(12000, () => {
          this.portalLeft.visible = true;

          // Move Rick & Morty into the left portal after 2s (14s total)
          this.time.delayedCall(14000, () => {
            if (this.rickText) this.rickText.setText("Rick: Que chato isso...");
            if (this.mortyText) this.mortyText.setText("Morty: Vamos embora...");

            // Make left portal visible and enable its body
            this.portalLeft.visible = true;
            this.portalLeft.body.enable = true;

            // Tween them into portalLeft.x, then destroy them
            this.tweens.add({
              targets: [this.rick, this.morty],
              x: this.portalLeft.x,
              duration: 2000,
              ease: 'Linear',
              onComplete: () => {
                if (this.rickText) this.rickText.destroy();
                if (this.mortyText) this.mortyText.destroy();
                if (this.rick) this.rick.destroy();
                if (this.morty) this.morty.destroy();
                this.portalLeft.setFillStyle(0x00ffff);
                this.portalLeft.setSize(50, 100);
                this.portalLeft.setVisible(true);

                this.time.delayedCall(1000, () => {
                  // Close the left portal
                  this.portalLeft.visible = false;

                  if (this.giullyaText) this.giullyaText.setText("??? : Vamos pra um mundo mágico agora!");

                  // Show right portal after 2 more seconds (19s total)
                  this.time.delayedCall(2000, () => {
                    // Make right portal visible and enable its body
                    this.portalRight.visible = true;
                    this.portalRight.body.enable = true;
                  });
                });
              }
            });
          });
        });
      }

      enterRightPortal(player, portal) {
        // When player (and presumably giullya is near) touches the right portal, go to next scene
        this.scene.start('RickMortyMessage');
      }
    }


    // =============================
    // GAME CONFIG
    // =============================
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 600,
      backgroundColor: "#000000",
      scene: [
       TimeBreakScene
      ],
      physics: {
        default: 'arcade',
        arcade: { debug: false }
      }
    };

    new Phaser.Game(config);
  </script>
</head>
<body>
</body>
</html>
