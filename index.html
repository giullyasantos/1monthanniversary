<!DOCTYPE html>
<html lang="pt-br">
<head>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Forum&family=Pixelify+Sans:wght@400..700&display=swap" rel="stylesheet">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Meu Amor - Game</title>
  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <script>

    // BaseCharacter.js
    class BaseCharacter extends Phaser.Physics.Arcade.Sprite {
      constructor(scene, x, y, textureKeys, config) {
        super(scene, x, y, textureKeys.idleRight);
        scene.add.existing(this);
        scene.physics.add.existing(this);

        this.textureKeys = textureKeys;
        this.config = config;
        this.direction = 'right';
        this.isJumping = false;
        this.walkFrame = 0;
        this.walkTimer = 0;

        this.setCollideWorldBounds(true);
        if (config.scale) this.setScale(config.scale);

        this.cursors = null; // Will be assigned externally
      }

      updateMovement(delta) {
        if (!this.cursors) return;

        const speed = this.config.speed || 160;
        const onGround = this.body.blocked.down;

        this.setVelocityX(0);

        if (this.cursors.left.isDown) {
          this.setVelocityX(-speed);
          this.direction = 'left';
        } else if (this.cursors.right.isDown) {
          this.setVelocityX(speed);
          this.direction = 'right';
        }

        if (this.cursors.up.isDown && onGround) {
          this.setVelocityY(-400);
          this.isJumping = true;
        }

        if (onGround && this.isJumping) {
          this.isJumping = false;
          this.walkTimer = 0;
          this.walkFrame = 0;
        }

        this.updateSprite(delta);
      }

      updateSprite(delta) {
        this.walkTimer += delta;
        let spriteKey = '';

        if (this.isJumping) {
          spriteKey = this.direction === 'left' 
            ? this.textureKeys.jumpLeft 
            : this.textureKeys.jumpRight;
          this.setTexture(spriteKey);
          return;
        }

        if (this.body.velocity.x !== 0) {
          if (this.walkTimer >= 100) {
            this.walkFrame = (this.walkFrame + 1) % 2;
            this.walkTimer = 0;
          }

          if (this.walkFrame === 0) {
            spriteKey = this.direction === 'left' 
              ? this.textureKeys.walkLeft 
              : this.textureKeys.walkRight;
          } else {
            spriteKey = this.direction === 'left' 
              ? this.textureKeys.idleLeft 
              : this.textureKeys.idleRight;
          }
        } else {
          spriteKey = this.direction === 'left' 
            ? this.textureKeys.idleLeft 
            : this.textureKeys.idleRight;
          this.walkFrame = 0;
          this.walkTimer = 0;
        }

        this.setTexture(spriteKey);
      }
    }
    // Player.js
    class Player extends BaseCharacter {
      // Static method to return all texture keys for the player
      static getTextureKeys() {
        return {
          idleLeft: 'gui_normal_left',
          idleRight: 'gui_normal_right',
          walkLeft: 'gui_normal_walk_left',
          walkRight: 'gui_normal_walk_right',
          jumpLeft: 'gui_normal_jump_left',
          jumpRight: 'gui_normal_jump_right',
          idleLeftGun: 'gui_normal_left_gun',
          idleRightGun: 'gui_normal_right_gun',
          walkLeftGun: 'gui_normal_walk_left_gun',
          walkRightGun: 'gui_normal_walk_right_gun',
          jumpLeftGun: 'gui_normal_jump_left_gun',
          jumpRightGun: 'gui_normal_jump_right_gun'
        };
      }

      static preload(scene) {
        // Normal
        scene.load.image('gui_normal_left', 'assets/gui_normal_left.png');
        scene.load.image('gui_normal_right', 'assets/gui_normal_right.png');
        scene.load.image('gui_normal_walk_left', 'assets/gui_normal_walk_left.png');
        scene.load.image('gui_normal_walk_right', 'assets/gui_normal_walk_right.png');
        scene.load.image('gui_normal_jump_left', 'assets/gui_normal_jump_left.png');
        scene.load.image('gui_normal_jump_right', 'assets/gui_normal_jump_right.png');

        // Gun Versions
        scene.load.image('gui_normal_left_gun', 'assets/gui_normal_left_gun.png');
        scene.load.image('gui_normal_right_gun', 'assets/gui_normal_right_gun.png');
        scene.load.image('gui_normal_walk_left_gun', 'assets/gui_normal_walk_left_gun.png');
        scene.load.image('gui_normal_walk_right_gun', 'assets/gui_normal_walk_right_gun.png');
        scene.load.image('gui_normal_jump_left_gun', 'assets/gui_normal_jump_left_gun.png');
        scene.load.image('gui_normal_jump_right_gun', 'assets/gui_normal_jump_right_gun.png');

        // Bullet
        const bulletCanvas = scene.textures.createCanvas('bullet', 2, 2);
        bulletCanvas.context.fillStyle = '#ffffff';
        bulletCanvas.context.fillRect(0, 0, 2, 2);
        bulletCanvas.refresh();
      }

      constructor(scene, x, y, config) {
        const textureKeys = Player.getTextureKeys();
        super(scene, x, y, textureKeys, config);
        this.hasGun = false;
        this.bullets = scene.physics.add.group({ defaultKey: 'bullet', maxSize: 50 });
        this.shootKey = scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
      }

      updateSprite(delta) {
        this.walkTimer += delta;
        let spriteKey = '';

        // Check if we have a gun to decide which textures to use
        const isGun = this.hasGun;
        
        if (this.isJumping) {
          spriteKey = this.direction === 'left' 
            ? (isGun ? this.textureKeys.jumpLeftGun : this.textureKeys.jumpLeft) 
            : (isGun ? this.textureKeys.jumpRightGun : this.textureKeys.jumpRight);
          this.setTexture(spriteKey);
          return;
        }

        if (this.body.velocity.x !== 0) {
          if (this.walkTimer >= 100) {
            this.walkFrame = (this.walkFrame + 1) % 2;
            this.walkTimer = 0;
          }

          if (this.walkFrame === 0) {
            spriteKey = this.direction === 'left'
              ? (isGun ? this.textureKeys.walkLeftGun : this.textureKeys.walkLeft)
              : (isGun ? this.textureKeys.walkRightGun : this.textureKeys.walkRight);
          } else {
            spriteKey = this.direction === 'left'
              ? (isGun ? this.textureKeys.idleLeftGun : this.textureKeys.idleLeft)
              : (isGun ? this.textureKeys.idleRightGun : this.textureKeys.idleRight);
          }
        } else {
          spriteKey = this.direction === 'left'
            ? (isGun ? this.textureKeys.idleLeftGun : this.textureKeys.idleLeft)
            : (isGun ? this.textureKeys.idleRightGun : this.textureKeys.idleRight);
          
          this.walkFrame = 0;
          this.walkTimer = 0;
        }

        this.setTexture(spriteKey);
      }

      updateMovement(delta) {
        super.updateMovement(delta);
        if (Phaser.Input.Keyboard.JustDown(this.shootKey) && this.hasGun) {
          this.shootBullet();
        }
      }

      shootBullet() {
        const offsetX = this.direction === 'right' ? 20 : -20;
        const bullet = this.bullets.create(this.x + offsetX, this.y, 'bullet');
        if (bullet) {
          bullet.setDisplaySize(10, 5);
          bullet.body.setVelocityX(this.direction === 'right' ? 400 : -400);

          this.scene.time.delayedCall(2000, () => {
            if (bullet.active) {
              this.bullets.killAndHide(bullet);
              bullet.body.reset(0, 0);
            }
          });
        }
      }
    }
    // Rick.js
    class Rick extends BaseCharacter {
      static preload(scene) {
        scene.load.image('rick_still_left', 'assets/characters/rick_still_left.png');
        scene.load.image('rick_still_right', 'assets/characters/rick_still_right.png');
        scene.load.image('rick_walking_left', 'assets/characters/rick_walking_left.png');
        scene.load.image('rick_walking_right', 'assets/characters/rick_walking_right.png');
      }

      // Add a static method to provide texture keys
      static getTextureKeys() {
        return {
          idleLeft: 'rick_still_left',
          idleRight: 'rick_still_right',
          walkLeft: 'rick_walking_left',
          walkRight: 'rick_walking_right',
        };
      }

      constructor(scene, x, y, config) {
        // Use Rick.getTextureKeys() directly, no need to pass textureKeys from outside
        super(scene, x, y, Rick.getTextureKeys(), config);
      }
    }
    // Morty.js
    class Morty extends BaseCharacter {
      static preload(scene) {
        scene.load.image('morty_still_left', 'assets/characters/morty_still_left.png');
        scene.load.image('morty_still_right', 'assets/characters/morty_still_right.png');
        scene.load.image('morty_walking_left', 'assets/characters/morty_walking_left.png');
        scene.load.image('morty_walking_right', 'assets/characters/morty_walking_right.png');
      }
      static getTextureKeys() {
        return {
          idleLeft: 'morty_still_left',
          idleRight: 'morty_still_right',
          walkLeft: 'morty_walking_left',
          walkRight: 'morty_walking_right',
        };
      }

      constructor(scene, x, y, config) {
        super(scene, x, y, Morty.getTextureKeys(), config);
      }
    }
    // Giullya.js
    class Giullya extends BaseCharacter {
      static preload(scene) {
        scene.load.image('giullya_still_left', 'assets/characters/giullya_still_left.png');
        scene.load.image('giullya_still_right', 'assets/characters/giullya_still_right.png');
        scene.load.image('giullya_walking_left', 'assets/characters/giullya_walking_left.png');
        scene.load.image('giullya_walking_right', 'assets/characters/giullya_walking_right.png');
        scene.load.image('giullya_jump_left', 'assets/characters/giullya_still_left.png');
        scene.load.image('giullya_jump_right', 'assets/characters/giullya_still_right.png');
      }

      static getTextureKeys() {
        return {
          idleLeft: 'giullya_still_left',
          idleRight: 'giullya_still_right',
          walkLeft: 'giullya_walking_left',
          walkRight: 'giullya_walking_right',
          jumpLeft: 'giullya_jump_left',
          jumpRight: 'giullya_jump_right',
        };
      }

      constructor(scene, x, y, config) {
        super(scene, x, y, Giullya.getTextureKeys(), config);
      }
    }

    // =============================
    // SCENE 1 - Start
    // =============================
    class StartScene extends Phaser.Scene {
      constructor() {
        super('StartScene');
      }

      create() {
        const titleText = this.add.text(400, 250, "Oi, meu amor,", {
          fontFamily: 'Pixelify Sans',
          fontWeight: '700',
          fontSize: '20px',
          color: "#ffffff",
          align: "center"
        }).setOrigin(0.5);

        const pressStartText = this.add.text(400, 350, "Pressione a BARRA DE ESPAÇO", {
          fontFamily: 'Pixelify Sans',
          fontSize: "20px",
          color: "#ffffff",
          align: "center"
        }).setOrigin(0.5);

        // Blink effect
        this.tweens.add({
          targets: pressStartText,
          alpha: 0,
          duration: 800,
          yoyo: true,
          repeat: -1
        });

        // Space to go to next scene
        this.input.keyboard.on('keydown-SPACE', () => {
          this.scene.start('RickMortyScene');
        });
      }
    }

    // =============================
    // RickMortyScene
    // =============================
    class RickMortyScene extends Phaser.Scene {
      constructor() {
        super('RickMortyScene');
        this.blockHit = false;
        this.mushroomCollected = false;
      }

      preload() {
        // Preload the player assets
        Player.preload(this);

        // Particle texture
        const graphics = this.make.graphics({ x: 0, y: 0, add: false });
        graphics.fillStyle(0xffffff, 1);
        graphics.fillCircle(2, 2, 2);
        graphics.generateTexture('particle', 4, 4);
      }

      create() {
        this.physics.world.setBounds(0, 0, 800, 600);
        this.physics.world.gravity.y = 500;

        // Ground
        const ground = this.add.rectangle(400, 590, 800, 20, 0x654321);
        this.physics.add.existing(ground, true);

        // Player config
        const playerConfig = { scale: 0.1, speed: 160 };

        // Create Player
        this.player = new Player(this, 100, 500, playerConfig);
        this.physics.add.collider(this.player, ground);
        this.player.cursors = this.input.keyboard.createCursorKeys();

        // Yellow Block
        this.block = this.add.rectangle(400, 400, 32, 32, 0xFFFF00);
        this.physics.add.existing(this.block, true);
        this.physics.add.collider(this.player, this.block, this.hitBlock, null, this);

        // Mushroom
        this.mushroom = this.add.rectangle(400, 368, 20, 20, 0x00FF00);
        this.physics.add.existing(this.mushroom);
        this.mushroom.visible = false;
        this.mushroom.body.setAllowGravity(false);

        // Portal
        this.portal = this.add.rectangle(750, 500, 50, 100, 0x00FFFF);
        this.physics.add.existing(this.portal, true);
        this.portal.visible = false;

        // Colliders and Overlaps
        this.physics.add.collider(this.mushroom, ground);
        this.physics.add.overlap(this.player, this.mushroom, this.collectMushroom, null, this);
        this.physics.add.overlap(this.player, this.portal, this.enterPortal, null, this);

        // Info Text
        this.infoText = this.add.text(400, 100, 
          "Bata de cabeça no bloco amarelo para liberar o cogumelo!\nUse as setas para mover, Espaço para pular.", 
          { font: "16px Arial", fill: "#ffffff", align: "center" }
        ).setOrigin(0.5);
      }

      emitParticleBurst(x, y) {
        const particleCount = 20;
        for (let i = 0; i < particleCount; i++) {
          const angle = Phaser.Math.Between(0, 360);
          const speed = Phaser.Math.Between(50, 150);
          const velocityX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;
          const velocityY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;

          const particle = this.add.sprite(x, y, 'particle');
          this.physics.add.existing(particle);
          particle.body.setVelocity(velocityX, velocityY);
          particle.body.setAllowGravity(false);

          this.tweens.add({
            targets: particle,
            alpha: 0,
            scale: { from: 1, to: 0 },
            duration: 500,
            onComplete: () => {
              particle.destroy();
            }
          });
        }
      }

      update(time, delta) {
        // Let the Player handle movement & animations
        this.player.updateMovement(delta);
      }

      hitBlock(player, block) {
        // Trigger the block hit effects only if the player is hitting from below
        if (player.body.touching.up) {
          // Handle mushroom release once
          if (!this.blockHit) {
            this.blockHit = true;
            this.mushroom.visible = true;
            this.mushroom.body.setAllowGravity(true);
          }

          // Change block color to red briefly
          block.setFillStyle(0xFF0000);
          this.time.delayedCall(500, () => {
            block.setFillStyle(0xFFFF00);
          });

          this.emitParticleBurst(block.x, block.y);
        }
      }

      collectMushroom(player, mushroom) {
        if (!this.mushroomCollected) {
          this.mushroomCollected = true;
          mushroom.destroy();
          this.portal.visible = true;
        }
      }

      enterPortal(player, portal) {
        this.scene.start('RickMortyMessage');
      }
    }    

    // =============================
    // TimeBreakScene
    // =============================
    class TimeBreakScene extends Phaser.Scene {
      constructor() {
        super('TimeBreakScene');
        this.enemyDead = false;
        this.fragmentCams = [];
        this.spawnPoint = { x: 100, y: 500 };

        this.rick = null;
        this.morty = null;
        this.giullya = null;
        this.rickText = null;
        this.mortyText = null;
        this.giullyaText = null;

        this.gun = null;
        this.portalLeft = null;
        this.portalRight = null;
        this.ground = null;
        this.player = null;
        this.enemy = null;
      }

      preload() {
        // Preload characters
        Player.preload(this);
        Rick.preload(this);
        Morty.preload(this);
        Giullya.preload(this);

        // The Player class already preloads the bullet and player textures.
        // Additional assets like Rick/Morty/Giullya textures are preloaded by their classes.
      }

      create() {
        this.physics.world.setBounds(0, 0, 800, 600);
        this.physics.world.gravity.y = 500;

        // Ground
        this.ground = this.add.rectangle(400, 590, 800, 20, 0x654321);
        this.physics.add.existing(this.ground, true);

        // Create Player
        const playerConfig = { scale: 0.05, speed: 160 };
        this.player = new Player(this, 100, 500, playerConfig);
        this.physics.add.collider(this.player, this.ground);
        this.player.cursors = this.input.keyboard.createCursorKeys();

        // Enemy
        this.enemy = this.add.rectangle(600, 500, 30, 50, 0xff00ff);
        this.physics.add.existing(this.enemy);
        this.enemy.body.setCollideWorldBounds(true);
        this.physics.add.collider(this.enemy, this.ground);

        // Gun
        this.gunSpawnX = 700;
        this.gunSpawnY = 550;
        this.addGun();

        // Overlaps
        this.physics.add.overlap(this.player.bullets, this.enemy, this.shootEnemy, null, this);
        this.physics.add.overlap(this.player, this.enemy, this.enemyHitPlayer, null, this);

        // Portals
        this.portalLeft = this.add.rectangle(100, 500, 50, 100, 0x00FFFF);
        this.physics.add.existing(this.portalLeft, true);
        this.portalLeft.visible = false;
        this.portalLeft.body.enable = false;

        this.portalRight = this.add.rectangle(700, 500, 50, 100, 0x00FFFF);
        this.physics.add.existing(this.portalRight, true);
        this.portalRight.visible = false;
        this.portalRight.body.enable = false;

        this.physics.add.overlap(this.player, this.portalRight, this.enterRightPortal, null, this);
      }

      update(time, delta) {
        // Player updates itself
        this.player.updateMovement(delta);

        // Enemy follows player if alive
        if (!this.enemyDead && this.enemy) {
          if (this.player.x < this.enemy.x) {
            this.enemy.body.setVelocityX(-100);
          } else {
            this.enemy.body.setVelocityX(100);
          }
        }
      }

      addGun() {
        this.gun = this.add.rectangle(this.gunSpawnX, this.gunSpawnY, 20, 10, 0xffff00);
        this.physics.add.existing(this.gun);
        this.physics.add.collider(this.gun, this.ground);
        this.physics.add.overlap(this.player, this.gun, this.collectGun, null, this);
      }

      collectGun(player, gun) {
        this.player.hasGun = true;
        gun.destroy();
        this.add.text(400, 100, "You got the gun! Press SPACE to shoot.", 
          { font: "16px Arial", fill: "#ffffff" }).setOrigin(0.5).setScrollFactor(0);
      }

      shootEnemy(bullet, enemy) {
        bullet.destroy();
        this.killEnemy();
      }

      enemyHitPlayer(player, enemy) {
        if (!this.enemyDead) {
          this.player.hasGun = false;
          this.respawnPlayer();
          this.addGun();
        }
      }

      respawnPlayer() {
        this.player.setPosition(this.spawnPoint.x, this.spawnPoint.y);
        this.player.body.setVelocity(0);
        this.player.isJumping = false;
        this.player.direction = 'right';
      }

      killEnemy() {
        if (this.enemyDead) return;
        this.enemyDead = true;
        this.enemy.destroy();

        // Fragmentation cameras
        const rows = 4;
        const cols = 5;
        const camWidth = 800 / cols;
        const camHeight = 600 / rows;
        const zoomFactor = 0.2;

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const cam = this.cameras.add(col * camWidth, row * camHeight, camWidth, camHeight);
            cam.setScroll(400, 300);
            cam.setZoom(zoomFactor);
            this.fragmentCams.push(cam);
          }
        }
        this.cameras.main.setVisible(false);

        // Player dialog after 1s
        this.time.delayedCall(1000, () => {
          this.add.text(400, 100, "O que foi que eu fiz, mano...", {
            font: "18px Arial", fill: "#fff", align: "center"
          }).setOrigin(0.5).setScrollFactor(0);
        });

        // Rick & Morty appear at ground level and move in after 3s total
        this.time.delayedCall(3000, () => {
          const rickConfig = { scale: 0.5, speed: 50 };
          const mortyConfig = { scale: 0.5, speed: 50 };
          this.rick = new Rick(this, 100, 500, rickConfig);
          this.morty = new Morty(this, 100, 500, mortyConfig);

          this.physics.add.collider(this.rick, this.ground);
          this.physics.add.collider(this.morty, this.ground);

          // Move them to player's vicinity
          this.tweens.add({
            targets: this.rick,
            x: this.player.x + 30,
            duration: 2000,
            ease: 'Linear'
          });
          this.tweens.add({
            targets: this.morty,
            x: this.player.x + 70,
            duration: 2000,
            ease: 'Linear'
          });

          // Show their dialogue after they arrive (about 5s total)
          this.time.delayedCall(5000, () => {
            this.rickText = this.add.text(400, 240, "Rick: Mds, e agora, bravos, olha o que você fez!!! Quem vai nos ajudar?", {
              font: "16px Arial", fill: "#0f0", align: "center"
            }).setOrigin(0.5).setScrollFactor(0);

            this.mortyText = this.add.text(400, 260, "Morty: ...", {
              font: "16px Arial", fill: "#0f0", align: "center"
            }).setOrigin(0.5).setScrollFactor(0);
          });
        });

        // Another character (Giullya) after 8s
        this.time.delayedCall(8000, () => {
          const giullyaConfig = { scale: 0.5, speed: 50 };
          this.giullya = new Giullya(this, 100, 500, giullyaConfig);
          this.physics.add.collider(this.giullya, this.ground);

          // Move giullya to the player
          this.tweens.add({
            targets: this.giullya,
            x: this.player.x - 30,
            duration: 2000,
            ease: 'Linear',
            onComplete: () => {
              // Show kiss text
              this.giullyaText = this.add.text(400, 340, "??? aparece e beija o jogador", {
                font: "16px Arial", fill: "#ff69b4", align: "center"
              }).setOrigin(0.5).setScrollFactor(0);

              // Remove fragment cameras
              this.fragmentCams.forEach(cam => this.cameras.remove(cam));
              this.fragmentCams = [];
              this.cameras.main.setVisible(true);

              // Rick & Morty react after 2s
              this.time.delayedCall(2000, () => {
                if (this.rickText) this.rickText.setText("Rick: Nossa, nem acredito que o amor faz isso.");
                if (this.mortyText) this.mortyText.setText("Morty: É incrível...");
              });
            }
          });
        });

        // Show left portal for Rick & Morty after 12s
        this.time.delayedCall(12000, () => {
          this.portalLeft.visible = true;

          // Move Rick & Morty into the left portal after 2s (14s total)
          this.time.delayedCall(14000, () => {
            if (this.rickText) this.rickText.setText("Rick: Que chato isso...");
            if (this.mortyText) this.mortyText.setText("Morty: Vamos embora...");

            // Make left portal visible and enable
            this.portalLeft.visible = true;
            this.portalLeft.body.enable = true;

            this.tweens.add({
              targets: [this.rick, this.morty],
              x: this.portalLeft.x,
              duration: 2000,
              ease: 'Linear',
              onComplete: () => {
                if (this.rickText) this.rickText.destroy();
                if (this.mortyText) this.mortyText.destroy();
                if (this.rick) this.rick.destroy();
                if (this.morty) this.morty.destroy();
                this.portalLeft.setFillStyle(0x00ffff);
                this.portalLeft.setSize(50, 100);
                this.portalLeft.setVisible(true);

                this.time.delayedCall(1000, () => {
                  // Close the left portal
                  this.portalLeft.visible = false;

                  if (this.giullyaText) this.giullyaText.setText("??? : Vamos pra um mundo mágico agora!");

                  // Show right portal after 2 more seconds (19s total)
                  this.time.delayedCall(2000, () => {
                    // Make right portal visible and enable its body
                    this.portalRight.visible = true;
                    this.portalRight.body.enable = true;
                  });
                });
              }
            });
          });
        });
      }

      enterRightPortal(player, portal) {
        this.scene.start('RickMortyMessage');
      }
    }


    // =============================
    // HarryPotterScene
    // =============================
    class BroomChallengeScene extends Phaser.Scene {
  constructor() {
    super('BroomChallengeScene');
    this.isGameOver = false;
    this.obstacleSpeed = 200;
    this.spawnTimer = 0;
    this.spawnInterval = 1500; // ms between obstacles
    this.gameDuration = 60000; // 1 minute in ms
  }

  preload() {
    // Player sprite
    this.load.image('player', 'assets/hogwarts/hogwarts_gui_normal.png');

    // Generate spell texture (red square)
    const graphics = this.make.graphics({ x: 0, y: 0, add: false });
    graphics.fillStyle(0xff0000, 1);
    graphics.fillRect(0, 0, 20, 20);
    graphics.generateTexture('spell', 20, 20);

    // Giullya sprite (using the same sprite for simplicity)
    this.load.image('giullya', 'assets/hogwarts/hogwarts_gui_normal.png');

    // Commented out audio loading
    // this.load.audio('hp_theme', 'assets/audio/hp_theme.mp3');
  }

  create() {
    this.cameras.main.setBackgroundColor('#000000');

    // Create Player using Player class
    const playerConfig = { scale: 0.5, speed: 0 };
    this.player = new Player(this, 100, 300, playerConfig);
    this.player.setTexture('player');
    this.physics.add.existing(this.player);
    this.player.body.setCollideWorldBounds(true);

    // Gravity for flappy-bird like movement
    this.physics.world.gravity.y = 600;
    this.player.cursors = this.input.keyboard.createCursorKeys();

    // Giullya
    this.giullya = this.physics.add.sprite(this.player.x - 50, this.player.y, 'giullya');
    this.giullya.setScale(0.5);
    this.giullya.body.setCollideWorldBounds(true);
    this.giullya.body.allowGravity = false;

    // Obstacles group
    this.obstacles = this.physics.add.group();

    // Check collision with spells
    this.physics.add.overlap(this.player, this.obstacles, this.hitSpell, null, this);

    // Commented out audio:
    // this.backgroundMusic = this.sound.add('hp_theme', { loop: true });
    // this.backgroundMusic.play();

    // Start timing the game
    this.startTime = this.time.now;

    // Score text or timer text if desired
    this.infoText = this.add.text(10, 10, 'Survive 60s!', { font: '20px Arial', fill: '#ffffff' });
  }

  update(time, delta) {
    if (this.isGameOver) return;

    // Flappy Bird style control
    if (this.player.cursors.space.isDown) {
      this.player.setVelocityY(-300);
    }

    // Update player
    this.player.update(delta);

    // Giullya follows player smoothly
    this.giullya.x = Phaser.Math.Linear(this.giullya.x, this.player.x - 50, 0.1);
    this.giullya.y = Phaser.Math.Linear(this.giullya.y, this.player.y, 0.1);

    // Spawn obstacles
    this.spawnTimer += delta;
    if (this.spawnTimer >= this.spawnInterval) {
      this.spawnTimer = 0;
      this.spawnObstacle();
    }

    // Check time elapsed
    const elapsed = this.time.now - this.startTime;
    if (elapsed >= this.gameDuration && !this.isGameOver) {
      this.endGameSuccess();
    }

    // Clean up obstacles
    this.obstacles.children.each(obstacle => {
      if (obstacle.x < -50) {
        obstacle.destroy();
      }
    });
  }

  spawnObstacle() {
    // Spawn a spell (red square) at a random y
    const y = Phaser.Math.Between(50, 550);
    const spell = this.obstacles.create(850, y, 'spell');
    spell.setVelocityX(-this.obstacleSpeed);
    spell.body.allowGravity = false;
  }

  hitSpell(player, spell) {
    if (this.isGameOver) return;
    this.isGameOver = true;
    player.setTint(0xff0000);
    this.physics.pause();

    // Stop music if we had it
    // if (this.backgroundMusic) this.backgroundMusic.stop();

    this.add.text(400, 300, 'Game Over!', {
      font: '32px Arial',
      fill: '#ffffff'
    }).setOrigin(0.5);

    this.time.delayedCall(3000, () => {
      this.scene.restart();
    });
  }

  endGameSuccess() {
    this.isGameOver = true;
    this.physics.pause();

    this.add.text(400, 300, 'You made it!', {
      font: '32px Arial',
      fill: '#ffffff'
    }).setOrigin(0.5);

    // Move to conclusion scene after a delay
    this.time.delayedCall(3000, () => {
      this.scene.start('BroomChallengeConclusion');
    });
  }
}

class BroomChallengeConclusion extends Phaser.Scene {
  constructor() {
    super('BroomChallengeConclusion');
  }

  preload() {
    // Load images for the transition
    // Using same sprite for simplicity or add actual images if available
    this.load.image('gui_hp', 'assets/hogwarts/hogwarts_gui_normal.png');
    this.load.image('gui_original', 'assets/hogwarts/hogwarts_gui_normal.png');
    this.load.image('giullya_hp', 'assets/hogwarts/hogwarts_gui_normal.png');
    this.load.image('giullya_original', 'assets/hogwarts/hogwarts_gui_normal.png');

    // A simple portal texture
    const graphics = this.make.graphics({x:0,y:0,add:false});
    graphics.fillStyle(0x00ffff, 1);
    graphics.fillCircle(40,40,40);
    graphics.generateTexture('portal',80,80);
  }

  create() {
    this.cameras.main.setBackgroundColor('#000000');

    // Characters from previous dimension
    this.add.image(200, 300, 'gui_hp').setScale(0.5);
    this.add.image(400, 300, 'gui_original').setScale(0.5);
    this.add.image(600, 300, 'giullya_hp').setScale(0.5);
    this.add.image(800, 300, 'giullya_original').setScale(0.5);

    // Dialogue
    this.add.text(400, 100, 'Gui (HP): “Mano, eu só quero ir pra Itália!”', {
      font: '20px Arial',
      fill: '#ffffff',
    }).setOrigin(0.5);

    this.add.text(400, 150, 'Gui (Original): “Tamo junto, irmão.”', {
      font: '20px Arial',
      fill: '#ffffff',
    }).setOrigin(0.5);

    // After a delay, show a portal and simulate Gui going through it
    this.time.delayedCall(3000, () => {
      const portal = this.add.sprite(400, 400, 'portal').setScale(1);
      this.add.text(400, 350, 'Um portal aparece...', {
        font: '18px Arial', fill: '#ffffff'
      }).setOrigin(0.5);

      // Move Gui (original) to portal after delay
      this.time.delayedCall(2000, () => {
        // Simulate Gui going into the portal
        // We can just fade out the scene
        this.tweens.add({
          targets: portal,
          alpha: 0,
          duration: 2000,
          onComplete: () => {
            // Move to next scene (PresidenteGuiScene)
            this.scene.start('PresidenteGuiScene');
          }
        });
      });
    });
  }
}

class PresidenteGuiScene extends Phaser.Scene {
  constructor() {
    super('PresidenteGuiScene');
  }

  preload() {
    // Placeholder textures
    const graphics = this.make.graphics({x:0,y:0,add:false});
    
    // Crowd member (gray rectangle)
    graphics.fillStyle(0x808080,1);
    graphics.fillRect(0,0,20,40);
    graphics.generateTexture('crowd_member',20,40);

    // Assassin (red rectangle)
    graphics.clear();
    graphics.fillStyle(0xff0000,1);
    graphics.fillRect(0,0,20,40);
    graphics.generateTexture('assassin',20,40);

    // Giullya sprite for the end
    this.load.image('giullya_end', 'assets/hogwarts/hogwarts_gui_normal.png');

    // Gui sprite (same as before)
    this.load.image('gui_president', 'assets/hogwarts/hogwarts_gui_normal.png');
  }

  create() {
    this.cameras.main.setBackgroundColor('#000000');

    // Gui making his speech
    this.add.text(400, 50, "Gui: “SE VOCÊ TEM MAIS DE 20 ANOS E ESCUTA TRAP, VOCÊ É UM FRACASSADO 2.0!”", {
      font: '16px Arial', 
      fill:'#ffffff', 
      wordWrap: { width: 600 }
    }).setOrigin(0.5);

    // Gui on stage
    this.add.image(400, 150, 'gui_president').setScale(0.5);

    // Instructions
    this.instructionText = this.add.text(400, 220, "Clique no assassino antes que ele atire!", {
      font: '20px Arial', fill: '#00ff00'
    }).setOrigin(0.5);
    
    // Create a crowd
    this.crowd = this.add.group();
    const assassinIndex = Phaser.Math.Between(0,9); 
    for (let i=0; i<10; i++){
      // Spread the crowd horizontally
      const x = 100 + i*60;
      const y = 350;
      let texture = (i === assassinIndex) ? 'assassin' : 'crowd_member';
      const person = this.add.sprite(x,y,texture).setInteractive();
      person.isAssassin = (i === assassinIndex);
      
      // Slight random scale variation for some variety
      person.setScale(Phaser.Math.FloatBetween(0.8,1.2));
      
      // Make them slightly spaced and possibly show them swaying
      this.tweens.add({
        targets: person,
        y: y + Phaser.Math.Between(-5,5),
        duration: 2000,
        yoyo: true,
        repeat: -1,
        ease: 'Sine.easeInOut'
      });
      
      this.crowd.add(person);
    }

    // Set input handler
    this.input.on('gameobjectdown', this.onObjectClicked, this);

    this.gameOver = false;
    this.assassinFound = false;

    // Add a small delay before the assassin is considered "active"
    this.time.delayedCall(3000, () => {
      // After 3s, the assassin is ready to shoot.
      // We can show a subtle hint or start a countdown.
      this.add.text(400, 280, "Atenção! Ele pode atirar a qualquer momento!", {
        font: '18px Arial', fill: '#ff0000'
      }).setOrigin(0.5);

      // Potentially start a timer that if reaches a certain time, game over.
      this.assassinTimer = this.time.delayedCall(5000, () => {
        if (!this.assassinFound && !this.gameOver) {
          this.fail();
        }
      });
    });
  }

  onObjectClicked(pointer, gameObject) {
    if (this.gameOver) return;

    if (gameObject.isAssassin) {
      // Correct target
      this.success();
    } else {
      // Wrong target
      // Shake the camera for feedback
      this.cameras.main.shake(200,0.01);
    }
  }

  success() {
    this.gameOver = true;
    this.assassinFound = true;
    if (this.assassinTimer) {
      this.assassinTimer.remove(false);
    }

    // Clear the crowd
    this.crowd.children.each(child => {
      child.destroy();
    });

    // Show success message
    this.add.text(400, 300, "Excelente! Você pegou o assassino!", {
      font: '24px Arial', fill:'#00ff00'
    }).setOrigin(0.5);

    // After a delay, show Giullya's ending line
    this.time.delayedCall(3000, () => {
      this.add.image(400, 350, 'giullya_end').setScale(0.5);
      this.add.text(400, 400, 'Giullya: “Você é o melhor Sonic 2024 atualizado 100%!”', {
        font: '18px Arial', fill:'#ffffff'
      }).setOrigin(0.5);

      // After a few seconds, end or go to next scene
      this.time.delayedCall(5000, () => {
        // Restart or go to another scene
        this.scene.start('BroomChallengeScene'); // Or a final ending scene
      });
    });
  }

  fail() {
    this.gameOver = true;
    // Assassin shot first
    this.crowd.children.each(child => {
      child.destroy();
    });

    this.add.text(400, 300, 'Você falhou! O assassino atirou primeiro!', {
      font: '24px Arial', fill: '#ff0000'
    }).setOrigin(0.5);

    this.time.delayedCall(3000, () => {
      this.scene.start('RealidadeFilhosScene'); // Or restart from a certain scene
    });
  }
}

class RealidadeFilhosScene extends Phaser.Scene {
  constructor() {
    super('RealidadeFilhosScene');
  }

  preload() {
    // Using geometric shapes instead of images:
    // Commented out image loads (just for reference)
    /*
    this.load.image('sala', 'assets/sala.png'); 
    this.load.image('arma_suja', 'assets/arma_suja.png'); 
    this.load.image('esponja', 'assets/esponja.png');
    this.load.image('pano', 'assets/pano.png');
    this.load.image('ian', 'assets/ian.png'); 
    this.load.image('diana', 'assets/diana.png');
    this.load.image('arup', 'assets/arup.png');
    this.load.image('giullya', 'assets/hogwarts/hogwarts_gui_normal.png');
    this.load.image('gui', 'assets/hogwarts/hogwarts_gui_normal.png');
    */

    // Sala (just a large rectangle as background)
    const bgGraphics = this.make.graphics({x:0,y:0,add:false});
    bgGraphics.fillStyle(0x654321,1); // Brownish for a cozy room
    bgGraphics.fillRect(0,0,800,600);
    bgGraphics.generateTexture('sala_shape',800,600);

    // Arma suja (a smaller rectangle to represent the dirty portal gun)
    const armaGraphics = this.make.graphics({x:0,y:0,add:false});
    armaGraphics.fillStyle(0x333333,1); // Dark gray
    armaGraphics.fillRect(0,0,100,50);
    armaGraphics.generateTexture('arma_suja_shape',100,50);

    // Ferramentas de limpeza (esponja e pano) as rectangles
    const esponjaGraphics = this.make.graphics({x:0,y:0,add:false});
    esponjaGraphics.fillStyle(0xffff00,1); // Yellow for sponge
    esponjaGraphics.fillRect(0,0,40,40);
    esponjaGraphics.generateTexture('esponja_shape',40,40);

    const panoGraphics = this.make.graphics({x:0,y:0,add:false});
    panoGraphics.fillStyle(0x00ffff,1); // Cyan for cloth
    panoGraphics.fillRect(0,0,40,40);
    panoGraphics.generateTexture('pano_shape',40,40);

    // Crianças (Ian, Diana, Arup) as simple circles
    const childGraphics = this.make.graphics({x:0,y:0,add:false});
    childGraphics.fillStyle(0xff69b4,1); // Pinkish for a child sprite
    childGraphics.fillCircle(15,15,15);
    childGraphics.generateTexture('child_shape',30,30);

    // Gui e Giullya as another set of circles
    const guiGraphics = this.make.graphics({x:0,y:0,add:false});
    guiGraphics.fillStyle(0x00ff00,1); // Green circle for Gui
    guiGraphics.fillCircle(20,20,20);
    guiGraphics.generateTexture('gui_shape',40,40);

    const giullyaGraphics = this.make.graphics({x:0,y:0,add:false});
    giullyaGraphics.fillStyle(0xff0000,1); // Red circle for Giullya
    giullyaGraphics.fillCircle(20,20,20);
    giullyaGraphics.generateTexture('giullya_shape',40,40);

    // Portal (circle)
    const portalGraphics = this.make.graphics({x:0,y:0,add:false});
    portalGraphics.fillStyle(0x00ffff,1);
    portalGraphics.fillCircle(40,40,40);
    portalGraphics.generateTexture('portal_italia_shape',80,80);
  }

  create() {
    this.cameras.main.setBackgroundColor('#000000');

    // Sala
    this.add.image(400, 300, 'sala_shape');

    // Crianças
    this.add.text(100, 100, "Ian, Diana e Arup brincam na sala...", {
      font: '16px Arial', fill:'#ffffff'
    });
    // Just place three child shapes for Ian, Diana, Arup
    this.add.image(150, 200, 'child_shape');
    this.add.image(200, 200, 'child_shape');
    this.add.image(250, 200, 'child_shape');

    this.add.text(400, 50, "Limpe a arma de portais suja de cocô em 60 segundos!", {
      font: '20px Arial', fill:'#ffffff'
    }).setOrigin(0.5);

    // Arma suja
    this.arma = this.add.sprite(400, 300, 'arma_suja_shape').setInteractive();

    // Nível de sujeira
    this.dirtCount = 5;

    // Criar ferramentas
    this.tools = [];
    this.createTool(350,450,'esponja_shape');
    this.createTool(450,450,'pano_shape');

    // Timer
    this.timeLimit = 60000; // 60s
    this.startTime = this.time.now;
    this.timerText = this.add.text(750, 20, "60s", {
      font: '20px Arial', fill:'#ffffff'
    }).setOrigin(1,0);

    this.gameOver = false;
  }

  createTool(x, y, texture) {
    const tool = this.add.sprite(x,y,texture).setInteractive({ draggable: true });
    this.input.setDraggable(tool);

    this.input.on('drag', (pointer, gameObject, dragX, dragY) => {
      if (gameObject === tool) {
        tool.x = dragX;
        tool.y = dragY;
      }
    });

    this.input.on('dragend', (pointer, gameObject) => {
      if (gameObject === tool && !this.gameOver) {
        // Checar sobreposição
        if (Phaser.Geom.Intersects.RectangleToRectangle(tool.getBounds(), this.arma.getBounds())) {
          this.cleanDirt();
        }
      }
    });

    this.tools.push(tool);
  }

  cleanDirt() {
    this.dirtCount--;
    if (this.dirtCount <= 0 && !this.gameOver) {
      this.success();
    }
  }

  update(time, delta) {
    if (this.gameOver) return;

    const elapsed = time - this.startTime;
    const remaining = Math.max(0, this.timeLimit - elapsed);
    const seconds = Math.ceil(remaining / 1000);
    this.timerText.setText(seconds + "s");

    if (remaining <= 0 && this.dirtCount > 0) {
      this.fail();
    }
  }

  success() {
    this.gameOver = true;
    this.add.text(400, 350, "Você limpou a arma!", {
      font: '24px Arial', fill:'#00ff00'
    }).setOrigin(0.5);

    // Gui e Giullya
    this.add.image(400, 400, 'gui_shape');
    this.add.image(450,400,'giullya_shape');

    this.add.text(400,450,"Giullya beija Gui na bochecha. Um portal se abre para a Itália!", {
      font: '18px Arial', fill:'#ffffff', align:'center', wordWrap: {width:500}
    }).setOrigin(0.5);

    // Portal
    this.add.image(400,500,'portal_italia_shape');

    this.time.delayedCall(5000, () => {
      // Próxima cena, se existir
      this.scene.start('CenaFinalItalia');
    });
  }

  fail() {
    this.gameOver = true;
    this.add.text(400, 350, "O tempo acabou! Você falhou!", {
      font: '24px Arial', fill:'#ff0000'
    }).setOrigin(0.5);

    this.time.delayedCall(3000, () => {
      this.scene.restart();
    });
  }
}


    // =============================
    // GAME CONFIG
    // =============================
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 600,
      backgroundColor: "#000000",
      scene: [
      RealidadeFilhosScene
      ],
      physics: {
        default: 'arcade',
        arcade: { debug: false }
      }
    };

    new Phaser.Game(config);
  </script>
</head>
<body>
</body>
</html>
